COSC.69.13
22F
Andrew Chen

# PA2
## Method
This program implements the flocking behavior for multi-robot systems as an emergent behavior of alignment, cohesion, and separation behaviors, weighted accordingly. The robot's linear velocity is a constant value, while the combination of the aforementioned behaviors modifies its angular velocity. The `flock` function in the `flocking_motion` node is responsible for continuously updating the angular velocity of each robot in accordance with the three behaviors.

Each behavior results in an angular factor in radians between pi and -pi. This factor represents how strongly the behavior would have the robot turn in a particular direction. Each factor is then multiplied by a corresponding behavior weight parameter to tune the relative influence of each behavior. The weighted factors are then added together, and the node publishes a Twist message with the constant linear velocity and the summed weighted factors as the angular velocity.

First, the node subscribes to the odometry topic for each robot. Using the metadata from the odometry message in the callback, the callback saves the odometry data in a dictionary keyed by the name of the robot whose odometry data is being considered.

Using this odometry data of each robot, the `flock` function checks for neighboring robots within a certain set distance from the current robot. If the robot has no neighbors, the behavior factors will all be 0. Otherwise, it will begin to calculate behavior factors.

The alignment behavior factor is implemented by first getting the average heading of all neighbors by adding the x and y components of their angle and computing a new angle from their sums. Then, the difference between the current heading (retrieved via odometry data) and the desired heading (the average heading of neighbors) is calculated. Then, this angular difference is transformed such that it is an angle between pi and -pi. Finally, it is divided by pi, the maximum magnitude angular difference, so that it becomes a number between 1 and -1. This scaled angular difference is multiplied by the maximum angular velocity (a parameter) and results in the alignment factor.

The cohesion behavior factor is implemented by getting the average (x,y) position of each neighbor. Using this average, a heading from the robot's location to the average position's location is computed using the difference in x and y and the arctan2 function. Then, the difference between the current heading (retrieved via odometry data) and the desired heading (the heading pointing towards the average neighbor position) is calculated. Then, this angular difference is transformed such that it is an angle between pi and -pi. Finally, it is divided by pi, the maximum magnitude angular difference, so that it becomes a number between 1 and -1. This scaled angular difference is multiplied by the maximum angular velocity (a parameter) and results in the cohesion factor.

If there are no neighbors within the separation range, a parameter, the separation behavior factor is 0. Otherwise, a separation factor is calculated for each neighbor within the separation range, and the overall separation behavior factor is the average of these individual separation factors. The separation factor for each neighbor within the separation range is calculated by first calculating the heading from the neighbor's position to the robot's position using the difference in x and y and the arctan2 function. Then, the difference between the current heading (retrieved via odometry data) and the desired heading (the heading away from the neighbor's position) is calculated. Then, this angular difference is transformed such that it is an angle between pi and -pi. Finally, it is divided by pi, the maximum magnitude angular difference, so that it becomes a number between 1 and -1. This scaled angular difference is multiplied by the maximum angular velocity (a parameter) and multiplied by (distance to neighbor)/(separation range). This results in an individual separation factor that is scaled by distance to the neighbor and severity of turn required.

## Evaluation
As shown in the videos, this program works in both stage and gazebo simulators. Robots will flock with nearby neighbors, avoid collisions, and travel together. However, depending on the weights provided to each behavior, robots can potentially collide and flocks can disperse. Sensible weights have been set in each launch file for each simulator, and the program performs very well with these parameters.